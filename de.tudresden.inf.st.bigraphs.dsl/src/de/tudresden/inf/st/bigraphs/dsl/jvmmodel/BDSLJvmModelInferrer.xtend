/*
 * generated by Xtext 2.22.0
 */
package de.tudresden.inf.st.bigraphs.dsl.jvmmodel

import com.google.inject.Inject
import de.tudresden.inf.st.bigraphs.dsl.BDSLLib
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BDSLDocument
import de.tudresden.inf.st.bigraphs.dsl.bDSL.UDFOperation
import de.tudresden.inf.st.bigraphs.dsl.bDSL.UdfCallExpression
import java.util.HashMap
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.TypesFactory
import org.eclipse.xtext.common.types.util.TypeReferences
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

//import de.tudresden.inf.st.bigraphs.dsl.scoping.BDSLUserDefinedExtensionLoader

/**
 * <p>Infers a JVM model from the source model.</p>
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>
 */
class BDSLJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	@Inject
	private TypeReferences references;

	@Inject
	private TypesFactory typesFactory;

	@Inject
	IQualifiedNameProvider nameProvider;

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
//	def dispatch void infer(BDSLDocument element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
//		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
//		var cnt = 0;
//		println("isPreIndexingPhase: " + isPreIndexingPhase)
////		if (isPreIndexingPhase) {
//		for (stmt : element.main.body.statements) {
////				cnt == 0 && 
//			if (stmt instanceof UDFOperation) {
//			}
//			cnt++
//		}
////		}
//	// An implementation for the initial hello world example could look like this:
////		acceptor.accept(element.toClass("my.company.greeting.MyGreetings")) [
////			for (greeting : element.greetings) {
////				members += greeting.toMethod("hello" + greeting.name, typeRef(String)) [
////					body = '''
////						return "Hello «greeting.name»";
////					'''
////				]
////			}
////		]
//	}
	
	val jvmTypesDefined = new HashMap<Class, JvmDeclaredType>();
	
	def dispatch void infer(UDFOperation udfop, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		for (exp : udfop.expression) {
			val exp1 = exp as UdfCallExpression
			val compNode = NodeModelUtils.getNode(exp1)
			val textClazzName = compNode.text
			val cleanedClazzName = textClazzName.substring(0, textClazzName.indexOf("(")).trim
//			println("compNode.text: " + textClazzName + " // compNode.toString: " + compNode.toString)
			
			// Go through all udf:import statements
			val bdslDoc = EcoreUtil2.getContainerOfType(exp1, BDSLDocument)
			val udfImports = bdslDoc.importDeclarationsUdf
			
			udfImports.forEach[entry | {
				try {
					var fullClassName = entry.importedNamespace
					if(entry.importedNamespace.contains("*")) {
						val cleanedNamespace = entry.importedNamespace.replaceAll("\\*", "").trim
						fullClassName = cleanedNamespace + cleanedClazzName
					} else if (fullClassName.contains(cleanedClazzName)) {
						// Nothing to do
					}
					println("fullClassName: " + fullClassName)
					val realClazz = Class.forName(fullClassName, false, BDSLLib.DCL)
					println("realClazz found: " + realClazz)
					var jvmInterfaceType = jvmTypesDefined.get(realClazz)
					if(jvmInterfaceType === null) {
						jvmInterfaceType = exp1.toInterface(realClazz.canonicalName, null) // BDSLUserDefinedConsumer.canonicalName//Function.canonicalName		
						jvmTypesDefined.put(realClazz, jvmInterfaceType)				
					}
//					println("new interface type - jvmInterfaceType: " + jvmInterfaceType);
					acceptor.accept(jvmInterfaceType)
					exp1.associate(jvmInterfaceType)
					exp1.type = jvmInterfaceType
				} catch(Exception e) {
					e.printStackTrace
				}
			}]
		}
//		for (exp : udfop.expression) {
//			val exp1 = exp as UdfCallExpression
//
//			println("exp1: " + exp1)
//
//			val typeRef = references.getTypeForName(exp1.name, exp1)
//			println("typeRef: " + typeRef)
//			if (typeRef instanceof JvmUnknownTypeReference) {
//				val jvmInterfaceType = exp1.toInterface(BDSLUserDefinedConsumer.canonicalName, null)
////					val jvmgentype = exp1.toClass(
////						"de.tudresden.inf.st.bigraphs.examples.interpreter.udf.Bla")
//				
//				//TODO: based on the number and types of arguments, choose the right interface
//				val jvmInterfaceType2 = references.findDeclaredType(BDSLUserDefinedConsumer, udfop)
//				println("jvmgentype: " + jvmInterfaceType)
//				println("jvmgentype: " + jvmInterfaceType2)
////					val typeRef = references.createTypeRef(jvmgentype)
////					val typeRef = typesFactory.createJvmAnyTypeReference()
//				acceptor.accept(jvmInterfaceType) [ //TODO
//////					members += stmt.toMethod("xxx", typeRef(Void))[
//////						body = '''empty body'''
//////					]
//				]
//				exp1.associate(jvmInterfaceType)
//				exp1.type = jvmInterfaceType
//			} else {
//				if (isQualifiedName(exp1.name)) {
//					val qfn = nameProvider.getFullyQualifiedName(typeRef.type)
//					println("qfn of standard type: " + qfn)
//					acceptor.accept(exp1.toClass(qfn)) [
////						
//					]
//					exp1.associate(typeRef.type)
//					exp1.type = typeRef.type
//
//				}
//			}
////				exp1.associate(jvmgentype)
//		}
	}

	def boolean isQualifiedName(String name) {
		return name.contains("\\.")
	}
	
//	/**
//   * pck = package name (qualified name)
//   */
//  def void buildClass(IJvmDeclaredTypeAcceptor acceptor,
//  	                 EuclidClass ec,String pck){
//  	var String qualifiedName = ec.name //ec.fullyQualifiedName.lastSegment
//  	if (pck != null){
//  	  qualifiedName = pck + "." + ec.name //ec.fullyQualifiedName.lastSegment
//  	}
//    acceptor.accept(ec.toClass(qualifiedName)).initializeLater [
//      documentation = ec.documentation
//      var JvmParameterizedTypeReference ext = ec.getExtends()
//      if (ext!=null && superTypes!=null) {
//        superTypes += ext.cloneWithProxies
//      }
//      var EList imps = ec.getImplements()
//      for (imp:imps){
//      	superTypes += imp.cloneWithProxies
//      }
//      for (methodElement : ec.members) {
//        if (methodElement instanceof EuclidFunction) {
//          val EuclidFunction me=methodElement as EuclidFunction
//          members += buildMethod(me)
//        }
//        if (methodElement instanceof EuclidConstructor) {
//          val EuclidConstructor me=methodElement as EuclidConstructor
//          members += buildConstructor(me)
//        }
//        if (methodElement instanceof EuclidField) {
//          val EuclidField fe=methodElement as EuclidField
//          members += buildField(fe)
//        }
//        if (methodElement instanceof EuclidInnerClass) {
//          val EuclidInnerClass ic=methodElement as EuclidInnerClass
//          members += buildInnerClass(ic,pck)
//        }
//       }
//     ]
//    }
}
