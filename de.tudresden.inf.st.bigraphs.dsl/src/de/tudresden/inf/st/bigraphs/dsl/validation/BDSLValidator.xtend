/*
 * generated by Xtext 2.21.0
 */
package de.tudresden.inf.st.bigraphs.dsl.validation

import de.tudresden.inf.st.bigraphs.dsl.bDSL.BDSLPackage
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BigraphVarReference
import de.tudresden.inf.st.bigraphs.dsl.bDSL.Closure
import de.tudresden.inf.st.bigraphs.dsl.bDSL.DataSource
import de.tudresden.inf.st.bigraphs.dsl.bDSL.LoadMethod
import de.tudresden.inf.st.bigraphs.dsl.bDSL.Signature
import de.tudresden.inf.st.bigraphs.dsl.bDSL.Site
import de.tudresden.inf.st.bigraphs.dsl.utils.BDSLUtil
import java.util.Objects
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.apache.commons.io.FilenameUtils
import de.tudresden.inf.st.bigraphs.dsl.bDSL.LoadFormat
import de.tudresden.inf.st.bigraphs.dsl.bDSL.AssignableBigraphExpression
import org.eclipse.xtext.EcoreUtil2
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BigraphVarDeclOrReference
import de.tudresden.inf.st.bigraphs.dsl.bDSL.AssignableBigraphExpressionWithExplicitSig
import de.tudresden.inf.st.bigraphs.dsl.bDSL.AbstractMainStatements
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BDSLVariableDeclaration2

//import java.security.Signature
/**
 * This class contains custom validation rules. 
 * 
 * "The other class is a subclass of that abstract class and is generated to the src/ folder in order to be edited by you. That is where you put the constraints in."
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * 
 * @author Dominik Grzelak
 */
class BDSLValidator extends AbstractBDSLValidator {

	public static val INVALID_NAME = 'invalidName'

	public static val INVALID_CLOSURE_DEFINITION = 'invalidClosure'

	public static val CYCLIC_VARIABLE_USAGE = 'cyclicBigraphVariable';

	public static val SITE_INDEX_IS_POSITIVE = 'siteIndexIsPositive';

	public static val LOAD_METHOD_MISSING_RESOURCE_IDENTIFIER = 'missingResourceIdentifier';
	public static val LOAD_METHOD_RES_EXT_AMBIGUOUS = 'fileExtensionMismatch';

	public static val ASSIGNMENT_SIGNATURES_MISMATCH = 'signatureMismatch';

//	@Check
//	def assignableBigraphExpressionSigCheck(BDSLVariableDeclaration2 container) {
//		if (container.value !== null) {
//			val localVarDecl = BDSLUtil.getLocalVarDecl(container.type as BigraphVarDeclOrReference)
//			if (localVarDecl.sig !== null) {
//				if ((container.expression instanceof AssignableBigraphExpressionWithExplicitSig)) {
//					val sigFromMethod = (container.expression as AssignableBigraphExpressionWithExplicitSig).sig
//					if (sigFromMethod !== localVarDecl.sig) {
//						error(
//							"Signature of method call doesn't match with signature on left-hand side of the variable declaration with name " +
//								localVarDecl.name, BDSLPackage.Literals.BDSL_VARIABLE_DECLARATION__TYPE,
//							ASSIGNMENT_SIGNATURES_MISMATCH);
//					}
//				}
//				if ((container.expression instanceof BigraphVarDeclOrReference)) {
//					val sigFromReference = BDSLUtil.getLocalVarDecl(container.expression as BigraphVarDeclOrReference).
//						sig
//					if (sigFromReference !== localVarDecl.sig) {
//						error(
//							"Signature of bigraph reference doesn't match with signature on left-hand side of the variable declaration with name " +
//								localVarDecl.name, BDSLPackage.Literals.BDSL_VARIABLE_DECLARATION__TYPE,
//							ASSIGNMENT_SIGNATURES_MISMATCH);
//					}
//				}
//			}
//		}
//	}

	@Check
	def loadMethodResourceFormat(LoadMethod loadMethod) {
		if (loadMethod.resourcePath === null || BDSLUtil.Strings.rawStringOf(loadMethod.resourcePath).isEmpty) {
			warning("The resourcePath is not set", BDSLPackage.Literals.LOAD_METHOD__RESOURCE_PATH,
				LOAD_METHOD_MISSING_RESOURCE_IDENTIFIER)
		} else {
			val ext = FilenameUtils.getExtension(BDSLUtil.Strings.rawStringOf(loadMethod.resourcePath))
			val loadFormatOfExt = LoadFormat.get(ext)
			if (Objects.isNull(loadFormatOfExt) || loadMethod.format != loadFormatOfExt) {
				warning("The extension of the resource path doesn't match with the specified load-as argument",
					BDSLPackage.Literals.LOAD_METHOD__RESOURCE_PATH, LOAD_METHOD_RES_EXT_AMBIGUOUS)
			}

		}

	}

	@Check
	def loadMethodNoResourceIdentifier(LoadMethod loadMethod) {
		if (BDSLUtil.Resources.getDataSourceFromIdentifier(BDSLUtil.Strings.rawStringOf(loadMethod.resourcePath)) ==
			DataSource.UNSPECIFIED) {
			warning("The resourcePath is missing a resource identifier",
				BDSLPackage.Literals.LOAD_METHOD__RESOURCE_PATH, LOAD_METHOD_MISSING_RESOURCE_IDENTIFIER)
		}
	}

	@Check
	def siteIndexIsPositive(Site siteExpression) {
		if (siteExpression.index <= 0) {
			error("The index of a site must be a positive integer", BDSLPackage.Literals.SITE__INDEX,
				SITE_INDEX_IS_POSITIVE);
		}
	}

	@Check
	def closureNamesAreNotDistinct(Closure closureExpression) {
		val t = newHashSet(closureExpression.value.toArray)
		if (closureExpression.value.size != t.size) {
			error("Names in the closure are not distinct.", BDSLPackage.Literals.CLOSURE__VALUE,
				INVALID_CLOSURE_DEFINITION);
		}
	}

	@Check
	def checkNoCycleInEntityHierarchy(BigraphVarReference varDecl) {
		if (varDecl.eContainer.eClass == BDSLPackage.Literals.BDSL_DOCUMENT) {
			return
		}

		var current = varDecl as EObject;
		while (Objects::nonNull(current)) {
			println("vcurrent" + current)
			if (current == varDecl.value) {
				warning("Cyclic bigraph variable reference", BDSLPackage::eINSTANCE.bigraphVarReference_Value)
				return
			}
			current = current.eContainer
		}
	}

	@Check
	def checkNameStartsWithCapital(Signature entity) {
		if (!Character.isUpperCase(entity.getName().charAt(0))) {
			warning("Signature name should start with a capital", BDSLPackage.Literals.SIGNATURE__NAME, INVALID_NAME);
		}
	}

}
