/*
 * generated by Xtext 2.21.0
 */
package de.tudresden.inf.st.bigraphs.dsl.validation

import de.tudresden.inf.st.bigraphs.dsl.bDSL.BDSLPackage
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BigraphVarReference
import de.tudresden.inf.st.bigraphs.dsl.bDSL.Closure
import de.tudresden.inf.st.bigraphs.dsl.bDSL.DataSource
import de.tudresden.inf.st.bigraphs.dsl.bDSL.LoadMethod
import de.tudresden.inf.st.bigraphs.dsl.bDSL.Signature
import de.tudresden.inf.st.bigraphs.dsl.bDSL.Site
import de.tudresden.inf.st.bigraphs.dsl.utils.BDSLUtil
import java.util.Objects
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.apache.commons.io.FilenameUtils
import de.tudresden.inf.st.bigraphs.dsl.bDSL.LoadFormat
import de.tudresden.inf.st.bigraphs.dsl.bDSL.AssignableBigraphExpression
import org.eclipse.xtext.EcoreUtil2
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BigraphVarDeclOrReference
import de.tudresden.inf.st.bigraphs.dsl.bDSL.AssignableBigraphExpressionWithExplicitSig
import de.tudresden.inf.st.bigraphs.dsl.bDSL.AbstractMainStatements
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BDSLVariableDeclaration2
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BDSLReferenceDeclaration
import de.tudresden.inf.st.bigraphs.dsl.bDSL.LocalVarDecl
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BDSLReferenceSymbol
import de.tudresden.inf.st.bigraphs.dsl.bDSL.LocalRuleDecl
import de.tudresden.inf.st.bigraphs.dsl.bDSL.RuleVarReference
import de.tudresden.inf.st.bigraphs.dsl.bDSL.LocalPredicateDeclaration
import de.tudresden.inf.st.bigraphs.dsl.bDSL.PredicateVarReference
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BRSDefinition
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BRSVarReference
import de.tudresden.inf.st.bigraphs.dsl.bDSL.ReferenceClassSymbol
import de.tudresden.inf.st.bigraphs.dsl.bDSL.BDSLExpression

//import java.security.Signature
/**
 * This class contains custom validation rules. 
 * 
 * "The other class is a subclass of that abstract class and is generated to the src/ folder in order to be edited by you. That is where you put the constraints in."
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * 
 * @author Dominik Grzelak
 */
class BDSLValidator extends AbstractBDSLValidator {

	public static val INVALID_NAME = 'invalidName'

	public static val INVALID_CLOSURE_DEFINITION = 'invalidClosure'

	public static val CYCLIC_VARIABLE_USAGE = 'cyclicBigraphVariable';

	public static val SITE_INDEX_IS_POSITIVE = 'siteIndexIsPositive';

	public static val LOAD_METHOD_MISSING_RESOURCE_IDENTIFIER = 'missingResourceIdentifier';
	public static val LOAD_METHOD_RES_EXT_AMBIGUOUS = 'fileExtensionMismatch';

	public static val ASSIGNMENT_SIGNATURES_MISMATCH = 'signatureMismatch';

	public static val ASSIGNMENT_TYPE_CHECKING = 'assignmentTypesNotMatch';

//	@Check
//	def checkTypeOfAssignment(BDSLReferenceDeclaration referenceDeclaration) {
//	}

	@Check
	def checkTypeOfAssignment(BDSLVariableDeclaration2 varDeclaration) {
		val variableLeft = varDeclaration.variable
		val valueRight = varDeclaration.value
//						System.out.println("Type right: " + valueRight)
//		System.out.println("checkSymbol: " + checkReferenceSymbolType(valueRight, LocalRuleDecl))

		if (valueRight instanceof AssignableBigraphExpressionWithExplicitSig) {
			return
		}

		if (variableLeft instanceof LocalVarDecl && (
			!BDSLUtil.bdslExpressionIsBigraphDefinition(valueRight) && !BDSLUtil.checkReferenceSymbolType(valueRight, LocalVarDecl))) {
			error(
				"Type of left-hand side of the variable declaration with name " +
					variableLeft.name + " doesn't match with type on right-hand side", BDSLPackage.Literals.BDSL_VARIABLE_DECLARATION2__VARIABLE,
				ASSIGNMENT_TYPE_CHECKING);
		}

		if (variableLeft instanceof LocalRuleDecl && (
			!BDSLUtil.bdslExpressionIsRuleDefinition(valueRight) && !BDSLUtil.checkReferenceSymbolType(valueRight, LocalRuleDecl))) {
			error(
				"Type of left-hand side of the rule declaration with name " +
					variableLeft.name + " doesn't match with type on right-hand side", BDSLPackage.Literals.BDSL_VARIABLE_DECLARATION2__VARIABLE,
				ASSIGNMENT_TYPE_CHECKING);
		}

		if (variableLeft instanceof LocalPredicateDeclaration && (
			!BDSLUtil.bdslExpressionIsBigraphDefinition(valueRight) &&
			!BDSLUtil.checkReferenceSymbolType(valueRight, LocalPredicateDeclaration))) {
			error(
				"Type of left-hand side of the predicate declaration with name " +
					variableLeft.name + " doesn't match with type on right-hand side", BDSLPackage.Literals.BDSL_VARIABLE_DECLARATION2__VARIABLE,
				ASSIGNMENT_TYPE_CHECKING);
		}

		if (variableLeft instanceof BRSDefinition && (
			!BDSLUtil.bdslExpressionIsBRSDefinition(valueRight) && !BDSLUtil.checkReferenceSymbolType(valueRight, BRSDefinition))) {
			error(
				"Type of left-hand side of the BRS declaration with name " +
					variableLeft.name + " doesn't match with type on right-hand side", BDSLPackage.Literals.BDSL_VARIABLE_DECLARATION2__VARIABLE,
				ASSIGNMENT_TYPE_CHECKING);
		}

	}

//	@Check
//	def assignableBigraphExpressionSigCheck(BDSLVariableDeclaration2 container) {
//		if (container.value !== null) {
//			val localVarDecl = BDSLUtil.getLocalVarDecl(container.type as BigraphVarDeclOrReference)
//			if (localVarDecl.sig !== null) {
//				if ((container.expression instanceof AssignableBigraphExpressionWithExplicitSig)) {
//					val sigFromMethod = (container.expression as AssignableBigraphExpressionWithExplicitSig).sig
//					if (sigFromMethod !== localVarDecl.sig) {
//						error(
//							"Signature of method call doesn't match with signature on left-hand side of the variable declaration with name " +
//								localVarDecl.name, BDSLPackage.Literals.BDSL_VARIABLE_DECLARATION__TYPE,
//							ASSIGNMENT_SIGNATURES_MISMATCH);
//					}
//				}
//				if ((container.expression instanceof BigraphVarDeclOrReference)) {
//					val sigFromReference = BDSLUtil.getLocalVarDecl(container.expression as BigraphVarDeclOrReference).
//						sig
//					if (sigFromReference !== localVarDecl.sig) {
//						error(
//							"Signature of bigraph reference doesn't match with signature on left-hand side of the variable declaration with name " +
//								localVarDecl.name, BDSLPackage.Literals.BDSL_VARIABLE_DECLARATION__TYPE,
//							ASSIGNMENT_SIGNATURES_MISMATCH);
//					}
//				}
//			}
//		}
//	}
	@Check
	def loadMethodResourceFormat(LoadMethod loadMethod) {
		if (loadMethod.resourcePath === null || BDSLUtil.Strings.rawStringOf(loadMethod.resourcePath).isEmpty) {
			warning("The resourcePath is not set", BDSLPackage.Literals.LOAD_METHOD__RESOURCE_PATH,
				LOAD_METHOD_MISSING_RESOURCE_IDENTIFIER)
		} else {
			val ext = FilenameUtils.getExtension(BDSLUtil.Strings.rawStringOf(loadMethod.resourcePath))
			val loadFormatOfExt = LoadFormat.get(ext)
			if (Objects.isNull(loadFormatOfExt) || loadMethod.format != loadFormatOfExt) {
				warning("The extension of the resource path doesn't match with the specified load-as argument",
					BDSLPackage.Literals.LOAD_METHOD__RESOURCE_PATH, LOAD_METHOD_RES_EXT_AMBIGUOUS)
			}

		}

	}

	@Check
	def loadMethodNoResourceIdentifier(LoadMethod loadMethod) {
		if (BDSLUtil.Resources.getDataSourceFromIdentifier(BDSLUtil.Strings.rawStringOf(loadMethod.resourcePath)) ==
			DataSource.UNSPECIFIED) {
			warning("The resourcePath is missing a resource identifier",
				BDSLPackage.Literals.LOAD_METHOD__RESOURCE_PATH, LOAD_METHOD_MISSING_RESOURCE_IDENTIFIER)
		}
	}

	@Check
	def siteIndexIsPositive(Site siteExpression) {
		if (siteExpression.index <= 0) {
			error("The index of a site must be a positive integer", BDSLPackage.Literals.SITE__INDEX,
				SITE_INDEX_IS_POSITIVE);
		}
	}

	@Check
	def closureNamesAreNotDistinct(Closure closureExpression) {
		val t = newHashSet(closureExpression.value.toArray)
		if (closureExpression.value.size != t.size) {
			error("Names in the closure are not distinct.", BDSLPackage.Literals.CLOSURE__VALUE,
				INVALID_CLOSURE_DEFINITION);
		}
	}

	@Check
	def checkNoCycleInEntityHierarchy(BigraphVarReference varDecl) {
		if (varDecl.eContainer.eClass == BDSLPackage.Literals.BDSL_DOCUMENT) {
			return
		}

		var current = varDecl as EObject;
		while (Objects::nonNull(current)) {
			println("vcurrent" + current)
			if (current == varDecl.value) {
				warning("Cyclic bigraph variable reference", BDSLPackage::eINSTANCE.bigraphVarReference_Value)
				return
			}
			current = current.eContainer
		}
	}

	@Check
	def checkNameStartsWithCapital(Signature entity) {
		if (!Character.isUpperCase(entity.getName().charAt(0))) {
			warning("Signature name should start with a capital", BDSLPackage.Literals.SIGNATURE__NAME, INVALID_NAME);
		}
	}

}
